---
layout: post
title:  "自动转换dkx(DuoKan For Kindle)到markdown的脚本"
date:   2014-3-10 14:47:39
excerpt: "一个简单的python脚本，自动转换dkx到jekyll可以识别的markdown格式文档"
categories: [tools]
tags: [python, booknotes]
---
一直习惯阅读电子书，使用DuoKan For Kindle也很久了，电子书的好处之一是可以保存书摘笔记的电子版，有空就可以查看一下。DuoKan For Kindle的存储格式
比较简单，存为dkx文件，每本书对应一个文件夹。因此写了这么一个python脚本，将dkx转为markdown格式，其中书名，作者，书摘，标题，时间都会保存下来，文件也会
自动命名为jekyll需要的命名格式。dkx为xml文件，因此用到了python的xml处理。
没有进行更精细的区分，比如UserName，以及time可能为1970-01-01的情况。

生成了两篇笔记，但是还是没看懂博客文章之间的跳转怎么做。
下面是个粘贴过来的链接，css格式很简单，大部分都写在了markdown内部。

* [《地狱》]({{ site.url }}booknotes/2014/03/10/地狱/)

<!--more-->

```
#!/usr/bin/python
# coding: utf-8

import os, sys
import time
import xml.dom.minidom

#base css format
mdheader = u'''---
layout: post
title:  "{0}-Notes"
date:   {1}
excerpt: "My bookNotes of {2}, generated by python."
categories: [BookNotes]
tags: [notes]
---
'''
timeFormat = '<span style="background-color: #F0F8FF; border-left: green solid thick;padding-left: 10px">%s</span>'
chapterTitleFormat = '#####_%s_'
bookNameFormat = '####<div style="text-align: right">%s</div>'
bookAuthorFormat = '#####<div style="text-align: right">%s</div>'
bookContentFormat = '> <span style="font-size: 14px">%s</span>'
userContentFormat = '<span class="glyphicon glyphicon-comment" style="text-index: 2em"></span>  %s'

class DKXContent:
    def __init__(self):
        self.BookName = ''
        self.BookAutho = ''
        self.readingData = [] 
    #parse the dkx generated by DUOKAN For Kindle.
    def parse(self, dkx_path):
        dom = xml.dom.minidom.parse(dkx_path)
        root = dom.documentElement
        self.BookName = self.getTextNodeValue(root, 'BookName')
        self.BookAuthor = self.getTextNodeValue(root, 'BookAuthor')
        items = root.getElementsByTagName('ReadingDataItem')
        for item in items:
            self.parseReadingDataItem(item)

    #parse the <ReadingDataItem> node-element
    def parseReadingDataItem(self, item):
        content = {}
        type = self.getTextNodeValue(item, 'Type')
        if (type in ('DIGEST', 'COMMENT')):
            content['Time'] = self.getTextNodeValue(item, 'LastModifyTime')
            content['ChapterTitle'] = self.getTextNodeValue(item, 'ChapterTitle')
            content['BookContent'] = self.getTextNodeValue(item, 'BookContent')
            content['UserContent'] = self.getTextNodeValue(item, 'UserContent')
            self.readingData.append(content)

    def getTextNodeValue(self, root, tag):
        node = root.getElementsByTagName(tag)[0]
        for node in node.childNodes:
            if node.nodeType in (node.TEXT_NODE, node.CDATA_SECTION_NODE):
                return node.data

        return ''

    #generate the markdown file.
    def generateMD(self):
        fileName = time.strftime('%Y-%m-%d-', time.localtime(time.time()))
        mdfile = open(fileName + self.BookName + '.markdown', 'w')
        postTime = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()));
        mdfile.write(mdheader.format(self.BookName, postTime, self.BookName).encode('utf-8'))
        mdfile.write(os.linesep)

        mdfile.write((bookNameFormat % self.BookName).encode('utf-8'))
        self.sepInMarkDown(mdfile)
        mdfile.write((bookAuthorFormat % self.BookAuthor).encode('utf-8'))
        self.sepInMarkDown(mdfile)
        mdfile.write('<!--more-->');
        self.sepInMarkDown(mdfile)

        for data in self.readingData:
            self.sepInMarkDown(mdfile)
            mdfile.write('-'*3)
            self.sepInMarkDown(mdfile)
            mdfile.write(timeFormat % (data['Time'].replace('T', ' ')))
            self.sepInMarkDown(mdfile)

            if len(data['ChapterTitle']) != 0:
                mdfile.write((chapterTitleFormat % data['ChapterTitle']).encode('utf-8'))
                self.sepInMarkDown(mdfile)
            mdfile.write((bookContentFormat % data['BookContent']).encode('utf-8'))
            self.sepInMarkDown(mdfile)
            if len(data['UserContent']) != 0:
                mdfile.write((userContentFormat % data['UserContent']).encode('utf-8'))

    def sepInMarkDown(self, mdfile):
        mdfile.write(os.linesep)
        mdfile.write(os.linesep)


dkxContent = DKXContent()
dkxContent.parse(sys.argv[1] if len(sys.argv) > 1 else 'dkx')
dkxContent.generateMD()
```
