---
layout: post
title:  "Codeforec Contest 466"
date:   2014-09-17 19:24:02
excerpt: "submissions for codeforce contest 466"
categories: [algorithm]
tags: [codeforce]
---

题目链接在[这里](http://codeforces.com/contest/466)

<!--more-->

### [A. Cheap Travel](http://codeforces.com/contest/466/problem/A)

题意： n站地铁，有两种买票的方式，a):一次一站a元，b):一次m站b元。问如何搭配可以最省钱。

分析： 有三种坐车的方式, a, b, a&b，找个最小值即可。

```
int main()
{
    ios::sync_with_stdio(0);
    int n, m, a, b;
    cin >> n >> m >> a >> b;
    int ans1 = n * a;
    int c = n / m;
    int r = n - m * c;
    int ans2 = c * b + r * a;
    int ans3 = (n % m) ? (c + 1) * b : c * b;

    cout << min(ans1, min(ans2, ans3)) << endl;
    return 0;
}
```

### [B. Wonder Room](http://codeforces.com/contest/466/problem/B)

题意： axb的宿舍，n个人住进去需要6xn的面积，如果不够可以增加宽高，问如何增加使得能住进去同时面积最小。

分析： 注意范围：1&ge;n, a, b&le;10<sub>9</sub>，因此理论上讲a的范围是[a, 6xn/b]，b的范围是[b, 6n/a]，在这个范围里搜索会超时。可以发现其中会有一些重复对。如果目标是构造6xn的面积，可以想到是短边&le;sqrt(6xn)，长边&ge;sqrt(6xn)，刚好&ge;6xn也可以类似的思路。即短边的范围&le;sqrt(6xn)。这样就可以避免重复对了。

```
int main()
{
    ios::sync_with_stdio(0);
    LL n, a, b;
    cin >> n >> a >> b;
    LL square = 6 * n;
    LL s = 0, a1 = a, b1 = b;
    bool swaped = false;

    if (a > b) {
        swaped = true;
        swap(a, b);
    }

    for (LL i = a; i * i <= square; ++i) {
        LL t = square / i;
        if (square % i != 0)
            ++t;
        if (t <= b)
            break;

        LL new_s = t * i;
        if (s == 0 || new_s < s) {
            s = new_s;
            a1 = i;
            b1 = t;
        }
    }

    if (swaped) {
        swap(a1, b1);
    }

    if (s == 0) {
        s = a * b;
    }

    cout << s << endl;
    cout << a1 << " " << b1 << endl;
    return 0;
}
```


### [C. Number of Ways](http://codeforces.com/contest/466/problem/C)  

题意： n长度的数组，要求分成三份，每份的元素和都是整个数组元素和的1/3， 问所有可能的组合数目。

分析： O(n)可以求出整个数组的元素和sum，因此题目变成求分割的办法使得每份都是sum/3。只要满足下列条件就可以分成三份：    
假设从左往右求和，加到某个数和为 sum / 3成为2分点，和为sum * 2 / 3称为2分点。
1. sum可以整除3.  
2. 2分点可以与前面任意一个1分点组合成一种办法。   
3. 1分点后面至少要有两个元素，2分点前面至少要有1个元素，后面至少要有一个元素。  
否则就没法分成3份了。  

```
int main()
{
    ios::sync_with_stdio(0);
    LL n, a[500005] = {0}, sum = 0, ans = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        sum += a[i];
    }

    LL k1 = 0;
    if (sum % 3 == 0) {
        LL s = 0, aver = sum / 3;
        for (int i = 0; i < n; ++i) {
            s += a[i];
            if (2 * aver == s && i > 0 && i < n - 1) {
                ans += k1;
            }
            if (aver == s && i < n - 2) {
                k1++;
            }
        }
    }

    cout << ans << endl;
    return 0;
}
```

### [D. Increase Sequence](http://codeforces.com/contest/466/problem/D)  

思考中...
