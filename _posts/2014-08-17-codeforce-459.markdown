---
layout: post
title:  "Codeforec Contest 459"
date:   2014-08-17 18:16:02
excerpt: "submissions for codeforce contest 459"
categories: [algorithm]
tags: [codeforce]
---

题目链接在[这里](http://codeforces.com/contest/459)

<!--more-->

> [A. Pashmak and Garden](http://codeforces.com/contest/459/problem/A)  

给定矩阵的两个点，判断正方形是否存在，存在则打印剩余的两个顶点。   
注意按三种情况处理就可以了。


```
int main()
{
    int x[4],y[4];
    cin >> x[0] >> y[0] >> x[1] >> y[1];

    //vertical
    if (x[0] == x[1])
    {
        x[2] = x[3] = x[0] + y[1] - y[0];
        y[2] = y[0];
        y[3] = y[1];
    }
    //horizontal
    else if (y[0] == y[1])
    {
        y[2] = y[3] = y[0] + x[1] - x[0];
        x[2] = x[0];
        x[3] = x[1];
    }
    else if (abs(x[0] - x[1]) == abs(y[0] - y[1]))
    {
        x[2] = x[1];
        y[2] = y[0];
        x[3] = x[0];
        y[3] = y[1];
    }
    else
    {
        cout << -1 << endl;
        return 0;
    }

    cout << x[2] << " "
         << y[2] << " "
         << x[3] << " "
         << y[3] << endl;

    return 0;
}

```

> [B. Pashmak and Flowers](http://codeforces.com/contest/459/problem/B)

要求得到最大的差，因此只要求出最大值和最小值就可以了。   
再次遍历分别得到个数相乘就是组合数。  
注意最大值最小值相等的情况，即所有花的beauty完全相等。此时组合数为C(n,2)。  
n的范围[2,2\*1e5]，n\*(n - 1)可能会超int范围，要用long long。


```
int main()
{
    LL n;
    LL b[200000] = {0};

    cin >> n;

    for (LL i = 0; i < n; ++i)
        cin >> b[i];

    LL maxb = max(b[0], b[1]);
    LL minb = min(b[0], b[1]);

    for (LL i = 2; i < n; ++i)
    {
        maxb = max(b[i], maxb);
        minb = min(b[i], minb);
    }

    LL max_cnt = 0, min_cnt = 0;
    for (LL i = 0; i < n; ++i)
    {
        if (b[i] == maxb)
            max_cnt++;
        if (b[i] == minb)
            min_cnt++;
    }

    LL cnt = max_cnt * min_cnt;
    if (maxb == minb)
    {
        cnt = n * (n - 1) / 2;
    }

    cout << (maxb - minb) << " " << cnt << endl;

    return 0;
}
```


> [C. Pashmak and Buses](http://codeforces.com/contest/459/problem/C)  

题目意思为有k辆车，n个学生做d天，能否使得没有任何学生会跟另外一个学生一直坐一辆车。  
k辆车d天的话，一共有k**d种排列，只要排列数&le;n即可。  
数值的范围： 1&ge;n,d&le;1000   1&ge;k&le;1000   

注意两点：  


n最大为1000，因此计算k**d过程中能够大于该值就可以返回了，否则会越界。  

 如何打印全排列，我用的是递归的办法，后来看到别人的做法，更加简洁。先贴下我的做法。  


```
typedef long long LL;
LL n,k,d, stu;
int a[1001][1001] = {0};
int b[1001];

void f(int day)
{
    if (day == d)
    {
        for (int i = 0; i < d; ++i)
            a[stu][i] = b[i];
        stu++;
        if (stu == n)
            return;
    }
    else if (day < d)
    {
        for (int i = 1; i <= k; ++i)
        {
            b[day] = i;
            f(day + 1);
            if (stu == n)
                return;
        }
    }
}

int main()
{
    cin >> n >> k >> d;
    int tmp = 1;
    for (int i = 0; i < d; ++i)
    {
        tmp *= k;
        if (tmp >= n)
            break;
    }
    if (tmp >= n)
    {
        f(0);
        for (int i = 0; i < d; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                cout << a[j][i] << " ";
            }
            cout << endl;
        }
    }
    else
    {
        cout << -1 << endl;
    }

    return 0;
}
```

一种比较清晰的打印全排列的方式， 以`k = 5; d = 4;`举个例子：  
0 &rarr; 1 1 1 1 1   
1 &rarr; 1 1 1 1 2   
2 &rarr; 1 1 1 1 3   
3 &rarr; 1 1 1 1 4   
4 &rarr; 1 1 1 1 5   
5 &rarr; 1 1 1 2 1   
6 &rarr; 1 1 1 2 2   
7 &rarr; 1 1 1 2 3   
8 &rarr; 1 1 1 2 4   
9 &rarr; 1 1 1 2 5   
其中&rarr;左边为索引值，右边为对应的排列数。  
对0,1,2,3,4排列看最后一列，5,6,7,8,9看最后两列，减1,可以猜测跟余数相关。  
0 &rarr; 0   
1 &rarr; 1   
2 &rarr; 2   
3 &rarr; 3   
4 &rarr; 4   
5 &rarr; 1 0   
6 &rarr; 1 1   
7 &rarr; 1 2   
8 &rarr; 1 3   
9 &rarr; 1 4   
具体看程序,打印前20个排列：

```
int n,k,d;

void f(int m)
{
    vector<int> v;
    while (m)
    {
        v.push_back(m % k);
        m /= k;
    }

    for (int i = 0; i < d - v.size(); ++i)
    {
        cout << 1 << " ";
    }
    for (int i = v.size() - 1; i >= 0; --i)
    {
        cout << v[i] + 1 << " ";
    }
    cout << endl;
}

int main()
{
    n = 20; k = 4; d = 5;
    for (int i = 0; i < n; ++i)
        f(i);

    return 0;
}
```

