---
layout: post
title:  "stl-algorithm笔记之find&find_if&find_if_not"
date: 2014-09-25 20:01:18
excerpt: "stl algorithm find&find_if&find_if_not notes"
categories: [stl]
tags: [stl]
---

###function template

```
template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value)

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);

template <class InputIt, class UnaryPredicate>
InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate p);
```


<!--more-->


###函数说明
1. find返回第一个匹配value的迭代器位置。  
2. find\_if返回第一个predicate p返回true的迭代器位置。  
3. find\_if\_not返回第一个predicate q返回false的迭代器位置。  

###函数行为  

```
template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value)
{
    for (; first != last; ++first) {
        if (*first == value) {
            return first;
        }
    }

    return last;
}

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
    for (; first != last; ++first) {
        if (p(*first)) {
            return first;
        }
    }

    return last;
}

template <class InputIt, class UnaryPredicate>
InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate p)
{
    for (; first != last; ++first) {
        if (!p(*first)) {
            return first;
        }
    }

    return last;
}
```

###注意
1. find find\_if find\_if\_not都不需要有序区间。  
2. 如果没有C++11,find\_if\_not的可以用find\_if(first, last, *not* p)来替代。 

###code

```
#include <iostream>
#include <algorithm>
#include <vector>

bool predicate1(int i)
{
    return i & 1;
}

bool predicate2(int i)
{
    return i > 0;
}

int main()
{
    int n1 = 3, n2 = 5;
    int a[] = {4, 2, 1, 3, 0};
    std::vector<int> v(a, a + 5);

    std::vector<int>::iterator result1 = std::find(v.begin(), v.end(), n1);
    if (result1 != v.end()) {
        std::cout << "v contains: " << n1 << std::endl;
    }
    else {
        std::cout << "v not contains: " << n1 << std::endl;
    }

    result1 = std::find(v.begin(), v.end(), n2);
    if (result1 != v.end()) {
        std::cout << "v contains: " << n2 << std::endl;
    }
    else {
        std::cout << "v not contains: " << n2 << std::endl;
    }

    result1 = std::find_if(v.begin(), v.end(), predicate1);
    if (result1 != v.end()) {
        std::cout << "v find odd number : " << *result1 << std::endl;
    }
    else {
        std::cout << "v not find even number " << std::endl;
    }

    //c++ 11
    // result1 = std::find_if_not(v.begin(), v.end(), predicate2);
    // if (result1 != v.end()) {
        // std::cout << "v find not positive: " << *result1 << std::endl;
    // }
    // else {
        // std::cout << "v not find not positive: " << std::endl;
    // }

    return 0;
}
//v contains: 3
//v not contains: 5
//v find odd number : 1
```

###Reference:
1. [CPPReference find](http://en.cppreference.com/w/cpp/algorithm/find)
2. [Effective stl](http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00CSWIJUQ/ref=pd_sim_b_5?ie=UTF8&refRID=18Z6X8EBY6YTNK0Q3EN9)

