---
layout: post
title:  "Codeforec Contest 238 Div.2"
date:   2014-03-25 11:24:53
categories: [algorithm]
tags: [codeforce]
---

> [A.Gravity Flip](http://codeforces.com/contest/405/problem/A)  

> > 实际上就是排序问题，非常简单

<!--more-->

```
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int n,a[100];
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> a[i];

    sort(a, a+n);
    for (int i = 0; i < n; ++i)
        cout << a[i] << " ";
    cout << endl;
    return 0;
}
```

> [B.Domino Effect](http://codeforces.com/contest/405/problem/B)    

> > 有几种情况domino是不会倒的,从左向右数：

> > 1. 在push-right,push-left中间的，如果中间的domino个数为奇数，则最中间的domino是不会倒的。
> > 2. 在push-left,push-right中间的不会倒。
> > 3. 最开始碰到了第一张操作的domino是push-right,那么之前的domino不会倒,可以归结到2.
> > 4. 最后一张操作的domino是push-left,那么之后的domino不会倒，可以归结到1.

```
#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

int main()
{
    int n, r = 0;
    char s[3000];
    cin >> n >> s;

    int lastL = -1, lastR = -2;
    for (int i = 0; i < strlen(s); ++i)
    {
        switch(s[i])
        {
            case 'L':
                {
                    if (lastR >= 0 && (i - lastR)%2 == 0)
                        r++;
                    lastL = i;
                }
                break;
            case 'R':
                {
                    r += (i - lastL - 1);
                    lastR = i;
                }
                break;
            default:
                break;
        }
    }
    if (lastL > lastR)
    {
        r += (strlen(s) - lastL - 1);
    }

    cout << r << endl;
    return 0;
}
```  

> [C.Unusual Product](http://codeforces.com/contest/405/problem/C)  

> > 以3x3矩阵为例

> > up = A<sub>00</sub>\*A<sub>00</sub> + A<sub>01</sub>\*A<sub>10</sub> + A<sub>02</sub>\*A<sub>20</sub>  
> > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ A<sub>10</sub>\*A<sub>01</sub> + A<sub>11</sub>\*A<sub>11</sub> + A<sub>12</sub>\*A<sub>21</sub>  
> > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ A<sub>20</sub>\*A<sub>02</sub> + A<sub>21</sub>\*A<sub>12</sub> + A<sub>22</sub>\*A<sub>22</sub>  
> > 可以看到只有对角线的数据是唯一的，因为是01,所以module之后只会剩下对角线的数据，即  
> > up = A<sub>00</sub>\*A<sub>00</sub> + A<sub>11</sub>\*A<sub>11</sub> + A<sub>22</sub>\*A<sub>22</sub>;

> > 同理，当修改i-th row/j-th col时对uｐ改变作用的也只是对角线的数据，同时，因为只有0/1改变  
> > 所以uｐ值每次改变也是0&rarr;1,1&rarr;0。

```
#include <stdio.h>

int main()
{
    //freopen("data", "r", stdin);
    int n,q,up = 0;
    int A[1000][1000];
    int r[1000000],rindex = 0;

    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            scanf("%d", &A[i][j]);

    for (int i = 0; i < n; ++i)
        if (A[i][i])
            up = up ? 0 : 1;

    scanf("%d", &q);
    for (int i = 0; i < q; ++i)
    {
        int qi;
        scanf("%d", &qi);
        if (qi == 3)
        {
            r[rindex++] = up;
        }
        else
        {
            int index;
            scanf("%d", &index);
            up = up ? 0 : 1;
        }
    }

    for (int i = 0; i < rindex; ++i)
    {
        printf("%d", r[i]);
    }
    printf("\n");

    return 0;
}
```

> [D.Toy Sum](http://codeforces.com/contest/405/problem/D)

> > 注意一个公式  
> > 如果x - 1 = s - y  
> > 则y = s + 1 -x

> > 对每一个ｘ&isin;X, y = s + 1 -x, 分两种情况分析：  

> > 1. y&notin;x, 此时加入这个ｙ即可。
> > 2. y&isin;x, 此时将x,y统一看待, x - 1 + y - 1 = x - 1 + s + 1 -x = s;    
> >    因此直接找到一组(j, s + 1 - j)加入结果即可。  
> >    因为n是&le;5\*10<sup>5</sup>,所以这组值肯定能找到。  

```
//http://codeforces.com/contest/405/problem/D
#include <stdio.h>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;

const int s = 1000001;
int n, m, xsum=0;
bool choosed[s];//记录哪一个已经被使用
vector<int> y;//结果存储
map<int, bool> x;//记录最开始已经选取的数字，int表示该数字，bool表示是否已经处理过。

//Notes:比较重要的公式，(k - 1) + (1000000 - k + 1) = 1000000
//在程序里即(k - 1) + (s - k) = s - 1,对任意一个ｋ只要将s-k放到ｙ里并标记x[k]已经处理就可以了。
//如果s-k在ｘ里，即已经使用，只要另外找任意一个组合(j, s-j)就可以了，因为
//(k - 1) + (s - k)  = s - 1 = (j - 1) + (s - j),并标记x里k-1,s-k都已经处理。

//找到任意一对没有被使用的组合，和为ｓ
int findMatchedPairs()
{
    static int i = 1;
    while (i <= s/2)
    {
        if (!choosed[i] && !choosed[s - i])
        {
            choosed[i] = true;
            choosed[s - i] = true;
            return i;
        }
        ++i;
    }

    //error.should never goto here.
    return -1;
}

int main()
{
    scanf("%d", &n);
    int temp;
    for (int i = 0; i < n; ++i)
    {
        scanf("%d", &temp);
        choosed[temp] = true;
        x[temp] = false;
    }
    vector<bool> flags(n, 0);

    for (map<int,bool>::iterator iter = x.begin(); iter != x.end(); ++iter)
    {
        //如果已经处理过，继续下一个
        if (iter->second)
            continue;

        int num = iter->first;
        //如果对应的位置被使用了已经，只能是ｘ里使用了
        if (choosed[s - num])
        {
            int j = findMatchedPairs();
            y.push_back(j);
            y.push_back(s - j);

            x[s - num] = true;
        }
        //没有使用则选取s-num, num-1 = (s-1) - (s - num) = 100000 - (s-num)
        else
        {
            choosed[s - num] = true;
            y.push_back(s - num);
        }
        x[num] = true;
    }

    printf("%d\n", y.size());
    for (unsigned int i = 0; i < y.size(); ++i)
        printf("%d ", y[i]);

    return 0;
}
```
